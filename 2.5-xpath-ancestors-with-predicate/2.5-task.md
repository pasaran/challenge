Челендж 2.5. Ближайшие предки с условием
========================================

Предположим есть `xpath`, выбирающий какой-то нодесет:
    <xsl:variable name="nodes" select="xpath"/>
И есть предикат, уточняющий этот нодесет: `xpath[test]`.

Как получить номер первого элемента, для которого `test = false()`?

Т.е. есть $nodes. Для каждой ноды вычисляем предикат, ну например вот так получается:
    $nodes[1]   $nodes[2]   $nodes[3]   ...   $nodes[n]
    true()      true()      false()     ...   true()
Вот в данном случае этот номер -- 3. Т.е. сперва две ноды с true(), а потом все, последовательность кончилась и встретился false().

На конкретном примере пытаюсь пояснить.  Предположим вот такой xml есть:
    <div>
       <div class="a">
           <i>
               <div class="b">
                   <div class="c">
                       <b>...</b> <!-- мы тут -->
                   </div>
               </div>
           </i>
       </div>
    </div>
Предположим, что текущий контекст это `<b>`.

В данном случае xpath `ancestor::*` -- все предки, а test это `@class`.

Я хочу понять, у какого ближайшего предка нет класса. В данном случае это <i>
Саму ноду я получить могу как-то так `ancestor::*[not(@class)][1]` -- ну или не 1, а last() или что-то типа того, не важно.
Но я не могу понять, что она третья (если считать снизу) среди всего нодесета из предков.

Совсем на самом деле, мне нужно пройти вверх по предкам и брать их до тех пор, пока у них есть класс.
Т.е. в данном случае это нодесет из двух нод -- div[@class=c] и div[@class=b]
Если бы я знал тот самый номер, я бы мог выбрать их как `ancestor::*[position() < 3]`.

Этот пример вымышленный. Хочется, конечно, для абстрактного случая.
Конечно же, хочется одним дешевым и быстрым xpath'ом обойтись. Ну и без рекурсивных вызовов шаблонов и функций точно.


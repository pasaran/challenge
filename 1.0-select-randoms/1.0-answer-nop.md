Решения by nop
==============

Пусть нужно выбрать k элементов из N.

Сортировка
----------
Сортируем весь список по значению `math:random()` и выбираем сколько нужно.

    <xsl:for-each select="items/item">
        <xsl:sort select="math:random()" data-type="number"/>
        <xsl:if test="position() &lt;= $k">
            <xsl:apply-templates select="." mode="random"/>
        </xsl:if>
    </xsl:for-each>

Резюме. Достаточно универсальный вариант.
Неплохо работает даже на больших объемах входных данных (например, 1000000 элементов сортируются без особых проблем).

Трудозатраты. Сортировка массива из N элементов стоит порядка `N * ln N`.

Рекурсивный выбор уникальных
----------------------------
Выбираем случайные ноды до тех пор, пока не накопится нужное количество уникальных элементов.

    <xsl:template name="random-set">
    <xsl:param name="result" select="/.."/>
        <xsl:choose>
            <xsl:when test="count($result) &lt; $k">
                <xsl:call-template name="random-set">
                    <xsl:with-param name="result" select="$result | dyn:evaluate(concat('/items/item[', floor(math:random() * $N) + 1, ']'))"/>
                </xsl:call-template>
            </xsl:when>
            <xsl:otherwise>
                <xsl:apply-templates select="$result" mode="random"/>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template>

Уникальность обеспечивается объединением нодесетов.
Резюме. Хорошо работает на маленьких k, при этом от N зависит слабо.

Трудозатраты. Порядка `k * k` -- рекурсивная вставка выбранных нод в текущий результат.

Вероятностный алгоритм
----------------------
Вычисляем число `p = k / N`. Проходим по всему списку и с вероятностью p выбираем элемент.
В результате в среднем будет выбрано `p * N = k` элементов.
Но поскольку рандом есть рандом, то вполне может получиться и меньше, чем k элементов.
Поэтому мы чуть-чуть увеличиваем p для того, чтобы после прохода всех элементов получить больше k элементов.
На самом деле, даже это ничего в общем-то не гарантирует, но сильно повышает шансы.
При этом на больших объемах входных данных это самый быстрый алгоритм.
Так что можно, если первый проход не дал нужного количества элементов, сделать второй проход.

    <xsl:variable name="p" select="($k * 1.05) div $N"/>

    <xsl:for-each select="items/item[math:random() &lt;= $p]">
        <xsl:if test="position() &lt;= $k">
            <xsl:apply-templates select="." mode="random"/>
        </xsl:if>
    </xsl:for-each>

Резюме. Неплохо работает при больших N и k (например, 500000 из 1000000).
При маленьких N и k сильно повышаются шансы, что не будет выбрано нужное количество элементов.

Трудозатраты. Линейны по N -- все делается в один полный проход.



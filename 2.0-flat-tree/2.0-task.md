Челендж 2.0. Нерекурсивный обход дерева
=======================================

Вводная
-------
Есть у нас такой небезызвестный сервис -- ярушка.
Пользователи пишут посты (в html в конечном счете), посты складывают в бульку,
потом при показе оттуда достаются и каждый раз пропускаются через xsl -- ну, например,
для того, чтобы раскрыть тег `<ya user="login"/>`, нарисовать cut и т.д.
При этом бОльшая часть тегов -- обычный html просто копируется как есть.
Но обход дерева совершается полный -- т.е. если юзер постарался и написал достаточно развесистый пост,
то можно упереться в ограничение по глубине рекурсии. Ну и вообще -- зачем обрабатывать каждый тег,
если на самом деле нужно это только для очень небольшого числа тегов.

**Идея**. Взять пост, например, такой:
    <div class="post">
        <p>Текст</p>
        <div><div>
            <span><b><i><ya user="nop"/></i></b></span>
        </div></div>
    </div>
и сделать из него вот такой:
    <![CDATA[<div class="post"><p>Текст</p><div><div><span><b><i>]]>
    <ya user="nop"/>
    <![CDATA[</i></b></span></div></div></div>]]>

Такой xml обрабатывать намного проще. Теперь это уже не дерево, а список нод -- текстовых и <ya user>.
Если хранить в бульке еще и такой предобработанный пост, то при выводе можно сэкономить.

Задача №1
---------
Написать xsl, который будет "распрямлять" html -- оставлять как есть теги `<ya>`, а остальное преобразовывать в текстовые ноды.
На входе какой-то html с вкраплениями тегов `<ya>`. Глубина рекурсии не ограничена -- это делается при записи поста, там нет
суровых ограничений, как на фронтендах.

Действие происходит в "реалиях Яндекса".


Вводная продолжается
--------------------
"Попробовали -- не жужжит" (с)

В результате каких-то причин, первый вариант не получился.
Программисты заленились и сказали: "Сложно больно. Пусть верстальщики сами разбираются".

Задача №2
---------
Вывести html (xml) произвольной глубины при включенном ограничении на глубину рекурсии.
В `xsltproc`'е глубина рекурсии задается параметром maxdepth
    xsltproc --maxdepth 10 test.xsl test.xml

На входе такой же html, как и в первом случае -- т.е. обычный html с тегами `<ya>`.
Обычные теги нужно скопировать как есть, на `<ya>` какой-то отдельный шаблон.
Ну вот такой, скажем:
    <xsl:template match="ya[@user]">
       <span class="b-user">
           <b><xsl:value-of select="substring(@user, 1, 1)"/></b>
           <xsl:value-of select="substring(@user, 2)"/>
       </span>
    </xsl:template>

